<template>
    <div class="document-template">
        <!-- 표지 -->
        <div class="cover pdf-content-item">
            <h1 class="main-title">{{projectInfo.projectName}}</h1>
            <div class="subtitle">도메인 주도 설계 기반 분석/설계 결과 보고서</div>
            <div class="logo-container">
                <img src="/static/image/logo.png" alt="MSAEZ Logo" class="logo">
            </div>
            <div class="footer">
                <p>Generated by MSAEZ – AI-powered Domain Design Tool | https://www.msaez.io</p>
            </div>
        </div>

    
        <!-- 목차 -->
        <div class="table-of-contents pdf-content-item">
            <h2>목 차</h2>
            <ol class="toc-list">
                <li>사용자 시나리오
                    <ul>
                        <li>액터 목록</li>
                        <li>사용자 스토리</li>
                        <li>비즈니스 규칙</li>
                        <li>분석된 바운디드 컨텍스트</li>
                    </ul>
                </li>
                <li>밸류 스트림(Value stream) 분석</li>
                <li>바운디드 컨텍스트 정의
                    <ul>
                        <li>분해 기준</li>
                        <li>분해 결과</li>
                        <li>컨텍스트 전략 맵</li>
                        <li>바운디드 컨텍스트 상세</li>
                    </ul>
                </li>
                <li>애그리거트 설계 (Aggregate Design)
                    <ul>
                        <li>애그리거트 모델</li>
                        <li>애그리거트 분석 (Analysis)</li>
                        <li>애그리거트 설계 기준</li>
                    </ul>
                </li>
                <li>이벤트스토밍 모델
                    <ul>
                        <li>시스템 전체 모델</li>
                        <li>바운디드 컨텍스트별 상세</li>
                    </ul>
                </li>
            </ol>
        </div>

    
        <!-- 본문 -->
        <!-- 사용자 시나리오 (actor & event) -->
        <div class="section">
            <div class="pdf-content-item">
                <h2>1. 사용자 시나리오</h2>
                <div v-if="projectInfo.draft">
                    <h3>1-1. 액터(Actor) 목록</h3>
                    <div v-if="groupedActors.length > 0" class="actor-section">
                        <div v-for="actor in groupedActors[0]" 
                            :key="actor.name" 
                            class="actor-item"
                        >
                            <div class="actor-name">
                                <strong>{{ actor.name }}</strong>
                                <span class="actor-lane">(Lane {{ actor.lane }})</span>
                            </div>
                            <div class="actor-events">
                                <span class="events-label">담당 이벤트:</span>
                                {{ actor.events.join(', ') }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div v-for="(actorGroup, groupIndex) in groupedActors.slice(1)" 
                :key="groupIndex"
                class="pdf-content-item"
            >
                <div class="actor-section">
                    <div v-for="actor in actorGroup" 
                        :key="actor.name" 
                        class="actor-item"
                    >
                        <div class="actor-name">
                            <strong>{{ actor.name }}</strong>
                            <span class="actor-lane">(Lane {{ actor.lane }})</span>
                        </div>
                        <div class="actor-events">
                            <span class="events-label">담당 이벤트:</span>
                            {{ actor.events.join(', ') }}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 사용자 스토리 -->
        <div class="section">
            <div class="pdf-content-item">
                <h3>1-2. 사용자 스토리</h3>
                <div v-if="projectInfo && projectInfo.userStory">
                    <div v-if="chunkedUserStory.length > 0" class="story-content">
                        <p v-for="(paragraph, pIndex) in chunkedUserStory[0]" 
                            :key="pIndex" 
                            class="story-paragraph"
                            v-html="paragraph"
                        >
                        </p>
                    </div>
                </div>
            </div>
            <div v-for="(storyChunk, index) in chunkedUserStory.slice(1)" 
                :key="index" 
                class="pdf-content-item"
            >
                <div class="story-content">
                    <p v-for="(paragraph, pIndex) in storyChunk" 
                        :key="pIndex" 
                        class="story-paragraph"
                        v-html="paragraph"
                    >
                    </p>
                </div>
            </div>
        </div>

        <!-- 밸류 스트림(Value stream) 분석 -->
        <div class="section pdf-content-item">
            <h2>2. 밸류 스트림(Value stream) 분석</h2>
            <div class="section-content">
                <div class="value-stream-description">
                    <p>({{ projectInfo.projectName }}) 에서 가치 중심의 업무 흐름을 단계별로 식별하고, 시스템 개선 지점과 도메인 이벤트 발생 위치를 정리</p>
                    <p>기능 요구사항 도출 및 도메인 모델링의 기초 자료로 활용</p>
                </div>
                
                <div class="value-stream-diagram">
                    <div class="work-in-progress">
                        <!-- <v-icon size="64" color="grey lighten-1">mdi-file-cad-box</v-icon>
                        <div class="wip-text">
                            <div class="wip-title">BPM 다이어그램 작업 예정</div>
                            <div class="wip-subtitle">밸류 스트림 다이어그램 BPM modeler 추후 작업.</div>
                        </div> -->
                        <bpmn-uengine-viewer
                            :style="{
                                width: '100%',
                                height: '100%'
                            }"
                            :bpmn="bpmXml"
                            :key="bpmXml"
                        />
                    </div>
                </div>
            </div>
        </div>

        <!-- 바운디드 컨텍스트 정의 -->
        <div class="section">
            <div class="pdf-content-item">
                <h2>3. 바운디드 컨텍스트 정의</h2>
                
                <!-- 분해 기준과 분해 결과를 하나의 pdf-content-item에 포함 -->
                <div class="section-content">
                    <!-- 분해 기준 -->
                    <h3>분해 기준</h3>
                    <div v-if="generationOption" class="criteria-section">
                    <!-- BCGenerationOption의 체크박스 UI를 가져옴 -->
                    <template v-for="(aspect, index) in generationOption.selectedAspects">
                        <v-card
                            :key="`card-${index}`"
                            class="mb-2"
                            outlined
                        >
                            <v-card-text>
                                <v-row class="ma-0 pa-0">
                                    <span class="font-weight-bold">{{ aspect }}</span>
                                </v-row>
                                <p>{{ getAspectDescription(aspect) }}</p>

                                <!-- 추가 입력 필드가 있는 경우 표시 -->
                                <v-row v-if="hasAspectDetails(aspect) && generationOption.aspectDetails[getAspectKey(aspect)]"
                                    class="ma-0 mt-3"
                                >
                                    <v-col cols="12" class="pa-0">
                                        <p class="mb-0">{{ generationOption.aspectDetails[getAspectKey(aspect)] }}</p>
                                    </v-col>
                                </v-row>
                            </v-card-text>
                        </v-card>
                    </template>

                    <!-- 추가 요구사항이 있는 경우 표시 -->
                    <v-card v-if="generationOption.additionalOptions" class="mt-4" outlined>
                        <v-card-text>
                            <div class="font-weight-bold mb-2">추가 요구사항:</div>
                            <p class="mb-0">{{ generationOption.additionalOptions }}</p>
                        </v-card-text>
                    </v-card>
                </div>

                    <!-- 분해 결과 -->
                    <h3>분해 결과</h3>
                    <div style="text-align: center;">
                        <vue-mermaid
                            :id="`mermaid-${renderKey}`"
                            :key="`mermaid-${renderKey}`"
                            :nodes="mermaidNodes"
                            type="graph TD"
                            :config="mermaidConfig"
                        ></vue-mermaid>
                    </div>
                </div>
            </div>
        </div>

        <!-- 바운디드 컨텍스트 추가정보 -->
        <div class="section">
            <div class="pdf-content-item">
                <h3>3-1. 바운디드 컨텍스트 상세</h3>
                <div class="section-content" v-if="selectedBoundedContext">
                    <!-- 컨텍스트 맵 -->
                    <h3>컨텍스트 전략 맵</h3>
                    <div style="text-align: center;">
                        <BoundedContextMatrix 
                            :boundedContexts="selectedBoundedContext.boundedContexts" 
                        />
                    </div>

                    <!-- 분해 이유 -->
                    <h3>분해 이유</h3>
                    <p>{{ selectedBoundedContext.thoughts }}</p>
                </div>
            </div>

            <!-- 상세 정보 테이블을 별도의 pdf-content-item으로 분리 -->
            <div class="pdf-content-item" v-if="selectedBoundedContext">
                <!-- 바운디드 컨텍스트 상세 정보 -->
                <h3>3-2. 바운디드 컨텍스트 상세 정보</h3>
                <v-simple-table class="bounded-context-table">
                    <thead>
                        <tr>
                            <th>바운디드 컨텍스트</th>
                            <th>역할</th>
                            <th>중요도</th>
                            <th>구현 전략</th>
                        </tr>
                    </thead>
                    <tbody>
                        <template v-for="bc in selectedBoundedContext.boundedContexts">
                            <tr :key="bc.name">
                                <td>{{ bc.alias }}</td>
                                <td>{{ bc.role }}</td>
                                <td>{{ bc.importance }}</td>
                                <td>{{ bc.implementationStrategy }}</td>
                            </tr>
                        </template>
                    </tbody>
                </v-simple-table>

                <!-- 컨텍스트 간 관계 -->
                <h3>컨텍스트 간 관계</h3>
                <v-simple-table class="relations-table">
                    <thead>
                        <tr>
                            <th>소스 컨텍스트</th>
                            <th>타겟 컨텍스트</th>
                            <th>관계 유형</th>
                            <th>상호작용 패턴</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="(relation, index) in selectedBoundedContext.explanations" 
                            :key="index"
                        >
                            <td>{{ relation.sourceContext }}</td>
                            <td>{{ relation.targetContext }}</td>
                            <td>{{ relation.relationType }}</td>
                            <td>{{ relation.interactionPattern }}</td>
                        </tr>
                    </tbody>
                </v-simple-table>
            </div>
        </div>

        <!-- 애그리거트 설계 섹션 -->
        <div class="section">
            <!-- 섹션 제목과 설명 -->
            <div class="pdf-content-item" v-if="getAggregateDrafts.length > 0">
                <h2>4. 애그리거트 설계 (Aggregate Design)</h2>
                <div class="section-content">
                    <p>각 바운디드 컨텍스트 내에서 비즈니스 불변 조건과 상태 일관성을 보장하기 위한 애그리거트를 정의</p>
                    <p>주요 명령(Command), 이벤트(Event), 엔티티(Entity), 값 객체(Value Object)를 식별하고, 트랜잭션 경계를 중심으로 모델을 구조화</p>
                </div>
            </div>

            <template v-for="(draft, index) in getAggregateDrafts">
                <!-- 머메이드 다이어그램 페이지 -->
                <div :key="`design-diagram-${index}`" class="pdf-content-item aggregate-page">
                    <h3>바운디드 컨텍스트: {{ draft.boundedContextAlias }} - 애그리거트 모델</h3>
                    <div v-if="draft.options" class="aggregate-models">
                        <template v-for="(option, optionIndex) in draft.options">
                            <div :key="optionIndex" class="aggregate-option">
                                <div class="mermaid-container">
                                    <vue-mermaid-string
                                        :id="`aggregate-mermaid-${index}-${optionIndex}`"
                                        :key="getAggregateMermaidRenderKey(index, optionIndex)"
                                        :value="getAggregateMermaidNodes(option.structure, index, optionIndex)"
                                    />
                                </div>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- 장단점 분석 페이지 -->
                <div :key="`design-analysis-${index}`" class="pdf-content-item">
                    <h3>바운디드 컨텍스트: {{ draft.boundedContextAlias }} - 애그리거트 분석</h3>
                    <div v-if="draft.options" class="analysis-content">
                        <template v-for="(option, optionIndex) in draft.options">
                            <div :key="optionIndex" class="analysis-section">
                                <h4>애그리거트 분석</h4>
                                <v-simple-table dense class="pros-cons-table">
                                    <thead>
                                        <tr>
                                            <th>항목</th>
                                            <th>장점</th>
                                            <th>단점</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="(key) in Object.keys(option.pros)" :key="key">
                                            <td class="font-weight-bold" style="width: 120px;">{{ key }}</td>
                                            <td>{{ option.pros[key] }}</td>
                                            <td>{{ option.cons[key] }}</td>
                                        </tr>
                                    </tbody>
                                </v-simple-table>
                            </div>
                        </template>
                    </div>
                </div>

                <!-- 설계 기준 페이지 1: 비즈니스 규칙과 엔티티 -->
                <div :key="`criteria-${index}-1`" class="pdf-content-item">
                    <h3>바운디드 컨텍스트: {{ draft.boundedContextAlias }} - 설계 기준 (1/3)</h3>
                    <div v-if="draft.options[0].analysisResult" class="design-criteria">
                        <!-- 비즈니스 규칙 -->
                        <div class="criteria-section">
                            <h4 class="section-title">비즈니스 규칙</h4>
                            <v-simple-table dense class="rules-table">
                                <tbody>
                                    <tr v-for="(rule, ruleIndex) in draft.options[0].analysisResult.businessRules" 
                                        :key="ruleIndex"
                                        class="criterion-row"
                                    >
                                        <td class="font-weight-bold" style="width: 150px;">{{ rule.name }}</td>
                                        <td>{{ rule.description }}</td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>

                        <!-- 엔티티 정의 -->
                        <div class="criteria-section">
                            <h4 class="section-title">엔티티 정의</h4>
                            <div v-for="(entity, entityName) in draft.options[0].analysisResult.entities" 
                                :key="entityName" 
                                class="entity-section"
                            >
                                <h5 class="entity-name">{{ entityName }}</h5>
                                <v-simple-table dense class="entity-table">
                                    <thead>
                                        <tr>
                                            <th>속성</th>
                                            <th>타입</th>
                                            <th>필수여부</th>
                                            <th>비고</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="prop in entity.properties" :key="prop.name">
                                            <td>{{ prop.name }}</td>
                                            <td>{{ prop.type }}</td>
                                            <td>{{ prop.required ? 'Y' : 'N' }}</td>
                                            <td>
                                                <span v-if="prop.isPrimaryKey">Primary Key</span>
                                                <span v-if="prop.foreignEntity">FK ({{ prop.foreignEntity }})</span>
                                                <span v-if="prop.values">{{ prop.values.join(', ') }}</span>
                                            </td>
                                        </tr>
                                    </tbody>
                                </v-simple-table>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 설계 기준 페이지 2: 이벤트와 인터페이스 -->
                <div :key="`criteria-${index}-2`" class="pdf-content-item">
                    <h3>바운디드 컨텍스트: {{ draft.boundedContextAlias }} - 설계 기준 (2/3)</h3>
                    <div v-if="draft.options[0].analysisResult" class="design-criteria">
                        <!-- 이벤트 정의 -->
                        <div class="criteria-section">
                            <h4 class="section-title">이벤트 흐름</h4>
                            <v-simple-table dense class="events-table">
                                <tbody>
                                    <tr v-for="(event, eventIndex) in draft.options[0].analysisResult.events" 
                                        :key="eventIndex"
                                        class="event-row"
                                    >
                                        <td class="font-weight-bold" style="width: 150px;">{{ event.displayName }}</td>
                                        <td>{{ event.description }}</td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>

                        <!-- 인터페이스 정의 -->
                        <div class="criteria-section">
                            <h4 class="section-title">인터페이스</h4>
                            <div v-for="(interfaceItem, interfaceName) in draft.options[0].analysisResult.interfaces" 
                                :key="interfaceName" 
                                class="interface-section"
                            >
                                <h5 class="interface-name">{{ interfaceName }}</h5>
                                <div v-for="(section, sectionIndex) in interfaceItem.sections" 
                                    :key="sectionIndex" 
                                    class="interface-section-detail"
                                >
                                    <div class="section-header">
                                        <strong>{{ section.name }}</strong> ({{ section.type }})
                                    </div>
                                    <div v-if="section.fields" class="section-fields">
                                        <v-simple-table dense class="interface-table">
                                            <thead>
                                                <tr>
                                                    <th>필드명</th>
                                                    <th>타입</th>
                                                    <th>필수여부</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="field in section.fields" :key="field.name">
                                                    <td>{{ field.name }}</td>
                                                    <td>{{ field.type }}</td>
                                                    <td>{{ field.required ? 'Y' : 'N' }}</td>
                                                </tr>
                                            </tbody>
                                        </v-simple-table>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 설계 기준 페이지 3: 사용자 스토리와 설계 기준 설명 -->
                <div :key="`criteria-${index}-3`" class="pdf-content-item">
                    <h3>바운디드 컨텍스트: {{ draft.boundedContextAlias }} - 설계 기준 (3/3)</h3>
                    <div v-if="draft.options[0].analysisResult" class="design-criteria">
                        <!-- 유저 스토리 -->
                        <div class="criteria-section">
                            <h4 class="section-title">사용자 스토리</h4>
                            <div v-for="(story, storyIndex) in draft.options[0].analysisResult.userStories" 
                                :key="storyIndex"
                                class="story-section"
                            >
                                <div class="story-header">
                                    <h5 class="story-title">{{ story.title }}</h5>
                                    <p class="story-description">{{ story.description }}</p>
                                </div>
                                <div class="story-acceptance">
                                    <strong>수용 기준:</strong>
                                    <ul>
                                        <li v-for="(criterion, criterionIndex) in story.acceptance" 
                                            :key="criterionIndex"
                                            class="acceptance-criterion"
                                        >
                                            {{ criterion }}
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- 설계 기준 설명 -->
                        <div v-if="draft.options[0].analysisResult.inference" class="criteria-section">
                            <h4 class="section-title">설계 기준 설명</h4>
                            <div class="criteria-explanation">
                                <p>{{ draft.options[0].analysisResult.inference }}</p>
                            </div>
                        </div>
                    </div>
                </div>
            </template>
        </div>

        <!-- 이벤트스토밍 모델 섹션 -->
        <div class="section">
            <!-- 섹션 제목과 설명 -->
            <div class="pdf-content-item" v-if="getEventStormingModels.length > 0">
                <h2>5. 이벤트스토밍 모델</h2>
                <div class="section-content">
                    <p>도출된 바운디드 컨텍스트와 애그리거트  결과를 기반으로 시스템의 동작 흐름과 반응 구조를 모델링</p>
                    <p>주요 도메인 이벤트, 커맨드, 리드모델 및 액터 간 상호작용을 시각적으로 정리</p>
                </div>
            </div>

            <!-- 각 모델별 페이지 -->
            <template v-for="(model, modelIndex) in getEventStormingModels">
                <!-- 각 바운디드 컨텍스트별 상세 정보 -->
                <template v-for="(bc, bcIndex) in model.BoundedContexts">
                    <div :key="`bc-${modelIndex}-${bcIndex}`" class="pdf-content-item">
                        <h3>모델: {{ model.modelName }} - 바운디드 컨텍스트: {{ bc.name }}</h3>
                        
                        <!-- 애그리게잇 정보 -->
                        <div v-if="bc.aggregate && bc.aggregate.length > 0" class="component-section">
                            <h5>애그리게잇</h5>
                            <v-simple-table dense class="component-table">
                                <thead>
                                    <tr>
                                        <th>이름</th>
                                        <th>설명</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="agg in bc.aggregate" :key="agg.id">
                                        <td>{{ agg.name }}</td>
                                        <td>{{ agg.description || agg.displayName }}</td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>

                        <!-- 커맨드 정보 -->
                        <div v-if="bc.command && bc.command.length > 0" class="component-section">
                            <h5>커맨드</h5>
                            <v-simple-table dense class="component-table">
                                <thead>
                                    <tr>
                                        <th>이름</th>
                                        <th>설명</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="cmd in bc.command" :key="cmd.id">
                                        <td>{{ cmd.name }}</td>
                                        <td>{{ cmd.description || cmd.displayName }}</td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>

                        <!-- 이벤트 정보 -->
                        <div v-if="bc.event && bc.event.length > 0" class="component-section">
                            <h5>이벤트</h5>
                            <v-simple-table dense class="component-table">
                                <thead>
                                    <tr>
                                        <th>이름</th>
                                        <th>설명</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="evt in bc.event" :key="evt.id">
                                        <td>{{ evt.name }}</td>
                                        <td>{{ evt.description || evt.displayName }}</td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>

                        <!-- 정책 정보 -->
                        <div v-if="bc.policy && bc.policy.length > 0" class="component-section">
                            <h5>정책</h5>
                            <v-simple-table dense class="component-table">
                                <thead>
                                    <tr>
                                        <th>이름</th>
                                        <th>설명</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="pol in bc.policy" :key="pol.id">
                                        <td>{{ pol.name }}</td>
                                        <td>{{ pol.description || pol.displayName }}</td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>
                    </div>
                </template>
            </template>
        </div>

        <!-- 애그리게잇 상세 정보 섹션 -->
        <div class="section">
            <div class="pdf-content-item" v-if="getEventStormingModels.length > 0">
                <h2>6. 애그리게잇 상세 정보</h2>
                <div class="section-content">
                    <p>각 바운디드 컨텍스트의 애그리게잇 루트와 관련 엔티티들의 상세 구조를 정의</p>
                    <p>도메인 모델의 핵심 구성요소인 애그리게잇의 속성, 연관 관계, 그리고 도메인 규칙을 상세하게 기술</p>
                </div>
            </div>

            <!-- 각 바운디드 컨텍스트별 애그리게잇 정보 -->
            <template v-for="(model, modelIndex) in getEventStormingModels">
                <template v-for="(bc, bcIndex) in model.BoundedContexts">
                    <div v-for="agg in bc.aggregate" :key="`agg-${bcIndex}-${agg.id}`" class="pdf-content-item">
                        <h3>바운디드 컨텍스트: {{ bc.name }} - 애그리게잇: {{ agg.name }}</h3>
                        
                        <!-- 애그리게잇 루트 필드 정보 -->
                        <div v-if="agg.aggregateRoot && agg.aggregateRoot.fieldDescriptors" class="component-section">
                            <h5>애그리게잇 루트 필드 정보</h5>
                            <v-simple-table dense class="field-table">
                                <thead>
                                    <tr>
                                        <th>필드명</th>
                                        <th>타입</th>
                                        <th>키 여부</th>
                                        <th>설명</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="field in agg.aggregateRoot.fieldDescriptors" :key="field.name">
                                        <td>{{ field.name }}</td>
                                        <td>{{ field.className }}</td>
                                        <td>{{ field.isKey ? '예' : '아니오' }}</td>
                                        <td>
                                            <span v-if="field.referenceClass">참조: {{ field.referenceClass }}</span>
                                            <span v-else-if="field.displayName">{{ field.displayName }}</span>
                                            <span v-else>-</span>
                                        </td>
                                    </tr>
                                </tbody>
                            </v-simple-table>
                        </div>

                        <!-- 엔티티 정보 -->
                        <div v-if="agg.aggregateRoot && agg.aggregateRoot.entities && agg.aggregateRoot.entities.elements" class="component-section">
                            <h5>엔티티 정보</h5>
                            <div v-for="(entity, entityId) in agg.aggregateRoot.entities.elements" :key="entityId" class="entity-detail">
                                <!-- 일반 클래스 -->
                                <template v-if="entity._type === 'org.uengine.uml.model.Class'">
                                    <div class="entity-header">
                                        <strong>{{ entity.name }}</strong>
                                        <span v-if="entity.displayName" class="entity-display-name">
                                            ({{ entity.displayName }})
                                        </span>
                                    </div>
                                    <v-simple-table dense class="field-table">
                                        <thead>
                                            <tr>
                                                <th>필드명</th>
                                                <th>타입</th>
                                                <th>키 여부</th>
                                                <th>설명</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr v-for="field in entity.fieldDescriptors" :key="field.name">
                                                <td>{{ field.name }}</td>
                                                <td>{{ field.className }}</td>
                                                <td>{{ field.isKey ? '예' : '아니오' }}</td>
                                                <td>
                                                    <span v-if="field.referenceClass">참조: {{ field.referenceClass }}</span>
                                                    <span v-else-if="field.displayName">{{ field.displayName }}</span>
                                                    <span v-else>-</span>
                                                </td>
                                            </tr>
                                        </tbody>
                                    </v-simple-table>
                                </template>

                                <!-- 열거형 -->
                                <template v-if="entity._type === 'org.uengine.uml.model.enum'">
                                    <div class="entity-header">
                                        <strong>{{ entity.name }}</strong>
                                        <span v-if="entity.displayName" class="entity-display-name">
                                            ({{ entity.displayName }})
                                        </span>
                                    </div>
                                    <v-simple-table dense class="enum-table">
                                        <thead>
                                            <tr>
                                                <th>값</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr v-for="(item, itemIndex) in entity.items" :key="itemIndex">
                                                <td>{{ item.value }}</td>
                                            </tr>
                                        </tbody>
                                    </v-simple-table>
                                </template>

                                <!-- Value Object -->
                                <template v-if="entity._type === 'org.uengine.uml.model.vo.Class'">
                                    <div class="entity-header">
                                        <strong>{{ entity.name }} (Value Object)</strong>
                                        <span v-if="entity.displayName" class="entity-display-name">
                                            ({{ entity.displayName }})
                                        </span>
                                    </div>
                                    <v-simple-table dense class="field-table">
                                        <thead>
                                            <tr>
                                                <th>필드명</th>
                                                <th>타입</th>
                                                <th>키 여부</th>
                                                <th>설명</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr v-for="field in entity.fieldDescriptors" :key="field.name">
                                                <td>{{ field.name }}</td>
                                                <td>{{ field.className }}</td>
                                                <td>{{ field.isKey ? '예' : '아니오' }}</td>
                                                <td>
                                                    <span v-if="field.referenceClass">참조: {{ field.referenceClass }}</span>
                                                    <span v-else-if="field.displayName">{{ field.displayName }}</span>
                                                    <span v-else>-</span>
                                                </td>
                                            </tr>
                                        </tbody>
                                    </v-simple-table>
                                </template>
                            </div>
                        </div>
                    </div>
                </template>
            </template>
        </div>
    </div>
</template>

<script>
import VueMermaid from '@/components/VueMermaid.vue';
import VueMermaidString from 'vue-mermaid-string';
import BoundedContextMatrix from '@/components/designer/modeling/generators/BoundedContextMatrix.vue';
import BpmnUengineViewer from '@/components/designer/bpmnModeling/bpmn/BpmnUengineViewer.vue';
import EventStormingModelCanvas from '@/components/designer/es-modeling/EventStormingModelCanvas.vue';

export default {
    name: 'DocumentTemplate',
    components: {
        VueMermaid,
        VueMermaidString,
        BoundedContextMatrix,
        BpmnUengineViewer,
        EventStormingModelCanvas
    },
    props: {
        projectInfo: {
            type: Object,
            required: true
        },
        cachedModels: {
            type: Object,
            required: true
        },
        eventStormingModels: {
            type: Object,
            required: true
        }
    },
    data() {
        return {
            renderKey: 0,
            mermaidConfig: {
                theme: 'default',
                startOnLoad: false,
                securityLevel: 'loose',
                flowchart: {
                    htmlLabels: true,
                    curve: 'basis',
                    rankSpacing: 100,
                    nodeSpacing: 100,
                    padding: 15
                },
                themeVariables: {
                    'groupBkgColor': '#fff',
                    'groupBorderColor': '#666',
                    'groupBorderWidth': '2px',
                    'groupPadding': 20
                }
            },
            mermaidDtos: {},
            bpmXml: null
        }
    },
    computed: {
        getProcessAnalysisMessages() {
            if (!this.projectInfo.draft) return [];
            return this.projectInfo.draft.filter(msg => msg.type === 'processAnalysis');
        },

        groupedActors() {
            const actors = [];
            this.getProcessAnalysisMessages.forEach(message => {
                if (message.content && message.content.analysisResult) {
                    actors.push(...message.content.analysisResult.actors);
                }
            });

            // 레인 번호로 정렬
            actors.sort((a, b) => a.lane - b.lane);

            // 레인 번호 기준으로 그룹화 (0-4, 5-9, ...)
            const groups = [];
            const groupSize = 7;
            const maxLane = Math.max(...actors.map(actor => actor.lane));
            
            for (let startLane = 0; startLane <= maxLane; startLane += groupSize) {
                const groupActors = actors.filter(actor => 
                    actor.lane >= startLane && actor.lane < startLane + groupSize
                );
                if (groupActors.length > 0) {
                    groups.push(groupActors);
                }
            }
            
            return groups;
        },

        formattedUserStory() {
            if (!this.projectInfo || !this.projectInfo.userStory) return [];
            
            // 원본 텍스트를 그대로 유지
            const text = this.projectInfo.userStory;
            
            // 빈 줄을 기준으로 문단 분리 (줄바꿈 2개 이상)
            return text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
        },

        chunkedUserStory() {
            if (!this.formattedUserStory) return [];
            
            const chunks = [];
            const TARGET_LENGTH = 1500;
            
            let currentChunk = [];
            let currentLength = 0;
            
            for (const paragraph of this.formattedUserStory) {
                // 현재 문단의 길이가 TARGET_LENGTH를 초과하는 경우
                if (paragraph.length > TARGET_LENGTH) {
                    // 현재 청크에 내용이 있으면 먼저 저장
                    if (currentChunk.length > 0) {
                        chunks.push(currentChunk);
                        currentChunk = [];
                        currentLength = 0;
                    }
                    
                    // 긴 문단을 문장 단위로 분할
                    const sentences = paragraph.match(/[^.!?]+[.!?]+/g) || [paragraph];
                    let currentSentences = [];
                    let sentenceLength = 0;
                    
                    for (const sentence of sentences) {
                        if (sentenceLength + sentence.length > TARGET_LENGTH) {
                            if (currentSentences.length > 0) {
                                chunks.push([currentSentences.join('')]);
                                currentSentences = [];
                                sentenceLength = 0;
                            }
                        }
                        currentSentences.push(sentence);
                        sentenceLength += sentence.length;
                    }
                    
                    if (currentSentences.length > 0) {
                        currentChunk = [currentSentences.join('')];
                        currentLength = sentenceLength;
                    }
                }
                // 일반적인 경우
                else {
                    // 현재 청크에 추가했을 때 너무 길어지면 새로운 청크 시작
                    if (currentLength + paragraph.length > TARGET_LENGTH) {
                        chunks.push(currentChunk);
                        currentChunk = [];
                        currentLength = 0;
                    }
                    
                    currentChunk.push(paragraph);
                    currentLength += paragraph.length;
                }
            }
            
            // 마지막 청크 추가
            if (currentChunk.length > 0) {
                chunks.push(currentChunk);
            }
            
            return chunks;
        },

        selectedBoundedContext() {
            if (!this.projectInfo.draft) return null;
            
            const boundedContextResult = this.projectInfo.draft.find(
                msg => msg.type === 'boundedContextResult'
            );
            
            if (!boundedContextResult) return null;
            
            // 선택된 관점의 결과 반환
            return boundedContextResult.result[boundedContextResult.selectedAspect];
        },

        mermaidNodes() {
            if (!this.selectedBoundedContext) return [];

            const nodes = [];
            const boundedContexts = this.selectedBoundedContext.boundedContexts || [];
            const relations = this.selectedBoundedContext.relations || [];
            
            // 도메인 타입별로 그룹화
            const domainGroups = {
                'Core Domain': [],
                'Supporting Domain': [],
                'Generic Domain': []
            };

            // 노드 생성 및 그룹화
            boundedContexts.forEach((bc, index) => {
                const node = {
                    id: `BC${index}`,
                    text: bc.alias,
                    editable: true,
                    edgeType: 'stadium',
                    style: this.getDomainStyle(bc.importance),
                    group: bc.importance || 'Generic Domain',
                    next: [],
                    link: []
                };
                nodes.push(node);
                
                if (bc.importance && domainGroups[bc.importance]) {
                    domainGroups[bc.importance].push(node);
                } else {
                    domainGroups['Generic Domain'].push(node);
                }
            });
            
            // 관계 정보 추가
            relations.forEach((rel) => {
                const sourceIndex = boundedContexts.findIndex(bc => bc.name === rel.upStream.name);
                const targetIndex = boundedContexts.findIndex(bc => bc.name === rel.downStream.name);
                
                if (sourceIndex !== -1 && targetIndex !== -1) {
                    const sourceNode = nodes[sourceIndex];
                    sourceNode.next.push(`BC${targetIndex}`);
                    sourceNode.link.push(`-->|"${rel.type}"|`);
                }
            });

            this.$nextTick(() => {
                this.renderKey++;
            });
            return nodes;
        },

        generationOption() {
            if (!this.projectInfo.draft) return null;
            
            const option = this.projectInfo.draft.find(
                msg => msg.type === 'bcGenerationOption'
            );
            
            return option ? option.generateOption : null;
        },

        getAggregateDrafts() {
            if (!this.projectInfo.draft) return [];
            
            const aggregateDraftMessages = this.projectInfo.draft.filter(msg => msg.type === 'aggregateDraftDialogDto');
            if (aggregateDraftMessages.length === 0) return [];

            const drafts = [];
            
            const aggregateDrafts = aggregateDraftMessages[0].selectedOptionItem;
            for (const [key, value] of Object.entries(aggregateDrafts)) {
                if (key === 'type') continue;
                
                let option = aggregateDraftMessages[0].draftOptions.find(option => option.boundedContext === key);
                if (value && value.boundedContext) {
                    drafts.push({
                        boundedContextAlias: value.boundedContext.alias || key,
                        options: [
                            {
                                structure: value.structure,
                                pros: value.pros,
                                cons: value.cons,
                                analysisResult: option.analysisResult
                            }
                        ]
                    });
                }
            }

            return drafts;
        },

        getEventStormingModels() {
            // 1. eventStormingModels가 존재하는지 체크
            if (!this.eventStormingModels) {
                return [];
            }

            // 2. 배열로 변환
            const modelArray = Array.isArray(this.eventStormingModels) 
                ? this.eventStormingModels 
                : Object.values(this.eventStormingModels);

            return modelArray.map(model => {
                // 3. 필요한 데이터가 있는지 체크
                if (!model || !model.information || !model.models) {
                    return null;
                }

                // 4. elements가 배열인지 확인하고 변환
                const elements = Array.isArray(model.models.elements) 
                    ? model.models.elements 
                    : Object.values(model.models.elements || {});

                // 5. BoundedContext 필터링 및 매핑
                const boundedContexts = elements
                    .filter(element => element && element._type.includes('BoundedContext'))
                    .map(bc => {
                        return {
                            id: bc.id,
                            name: bc.name,
                            aggregate: elements.filter(
                                element => element && element._type.includes('Aggregate') && element.boundedContext.id === bc.id
                            ),
                            command: elements.filter(
                                element => element && element._type.includes('Command') && element.boundedContext.id === bc.id
                            ),
                            event: elements.filter(
                                element => element && element._type.includes('Event') && element.boundedContext.id === bc.id
                            ),
                            policy: elements.filter(
                                element => element && element._type.includes('Policy') && element.boundedContext.id === bc.id
                            ),
                            actor: elements.filter(
                                element => element && element._type.includes('Actor') && element.boundedContext.id === bc.id
                            )
                        };
                    });

                // 6. 결과 반환
                return {
                    modelName: model.information.projectName,
                    BoundedContexts: boundedContexts
                };
            }).filter(Boolean); // null 값 제거
        }
    },
    mounted() {
        this.generateBPMN();
        console.log(this.bpmXml);
    },
    methods: {
        getDomainStyle(importance) {
            const colors = {
                'Core Domain': 'fill:#8fbcaa,stroke:#333,stroke-width:2px',
                'Supporting Domain': 'fill:#b39ddb,stroke:#333,stroke-width:2px',
                'Generic Domain': 'fill:#9e9e9e,stroke:#333,stroke-width:2px'
            };
            return colors[importance] || 'fill:#ddd,stroke:#333,stroke-width:2px';
        },

        getAspectDescription(aspect) {
            const descriptions = {
                [this.$t('DevideBoundedContextDialog.domainAspect')]: 
                    this.$t('BCGenerationOption.domainAspectDescription'),
                [this.$t('DevideBoundedContextDialog.processAspect')]: 
                    this.$t('BCGenerationOption.processAspectDescription'),
                [this.$t('DevideBoundedContextDialog.organizationalAspect')]: 
                    this.$t('BCGenerationOption.organizationalAspectDescription'),
                [this.$t('DevideBoundedContextDialog.personaAspect')]: 
                    this.$t('BCGenerationOption.personaAspectDescription'),
                [this.$t('DevideBoundedContextDialog.transactionPerformanceAspect')]: 
                    this.$t('BCGenerationOption.transactionPerformanceAspectDescription'),
                [this.$t('DevideBoundedContextDialog.infrastructureAspect')]: 
                    this.$t('BCGenerationOption.infrastructureAspectDescription')
            };
            return descriptions[aspect] || '';
        },

        hasAspectDetails(aspect) {
            return aspect === this.$t('DevideBoundedContextDialog.organizationalAspect') ||
                aspect === this.$t('DevideBoundedContextDialog.infrastructureAspect');
        },

        getAspectKey(aspect) {
            if(aspect === this.$t('DevideBoundedContextDialog.organizationalAspect')){
                return 'organizationalAspect';
            }else if(aspect === this.$t('DevideBoundedContextDialog.infrastructureAspect')){
                return 'infrastructureAspect';
            }
        },

        getAggregateMermaidNodes(structure, index, optionIndex) {
            const key = `${index}-${optionIndex}`;
            if (!this.mermaidDtos[key]) {
                this.mermaidDtos[key] = {
                    mermaidString: '',
                    renderKey: 0
                };
            }

            const initConfig = {
                theme: "default",
                themeVariables: {
                    fontSize: "14px"
                }
            };
            let config = "%%{init: " + JSON.stringify(initConfig) + "}%%\n";
            let mermaidString = config + "graph TD\n";
            
            if (!structure || !Array.isArray(structure)) {
                mermaidString += "None[None]\n";
                return mermaidString;
            }
            
            const groups = {}; 
            const relSet = new Set(); 
            
            const getValidAlias = (alias) => {
                return alias.replace(/[^a-zA-Z0-9가-힣_]/g, '');
            }
            
            const addClassToGroup = (groupKey, classId, label, role) => {
                if (!groups[groupKey]) {
                    groups[groupKey] = { id: groupKey, label: label, classes: {} };
                }
                if (!groups[groupKey].classes[classId]) {
                    groups[groupKey].classes[classId] = { id: classId, label: label, role: role };
                } else if (role === "Aggregate Root" && groups[groupKey].classes[classId].role !== "Aggregate Root") {
                    groups[groupKey].classes[classId].role = "Aggregate Root";
                }
            };

            structure.forEach(item => {
                if (item.aggregate && item.aggregate.alias) {
                    const aggAlias = item.aggregate.alias;
                    const aggKey = getValidAlias(aggAlias);
                    addClassToGroup(aggKey, aggKey, aggAlias, "Aggregate Root");
                    
                    if (Array.isArray(item.enumerations)) {
                        item.enumerations.forEach(enumeration => {
                            if (!enumeration.alias) return;
                            const enumKey = getValidAlias(enumeration.alias);
                            addClassToGroup(aggKey, enumKey, enumeration.alias, "Enumeration");   
                            relSet.add(`    ${aggKey} --> ${enumKey}`);
                        });
                    }
                    
                    if (Array.isArray(item.valueObjects)) {
                        item.valueObjects.forEach(vo => {
                            if (!vo.alias) return;
                            const voKey = getValidAlias(vo.alias);
                            addClassToGroup(aggKey, voKey, vo.alias, "Value Object");
                            relSet.add(`    ${aggKey} --> ${voKey}`);
                            
                            if (vo.referencedAggregate && vo.referencedAggregate.alias) {
                                const refAggAlias = vo.referencedAggregate.alias;
                                const refAggKey = getValidAlias(refAggAlias);
                                addClassToGroup(refAggKey, refAggKey, refAggAlias, "Aggregate Root");
                                
                                if (aggKey !== refAggKey) {
                                    relSet.add(`    ${voKey} --> ${refAggKey}`);
                                }
                            }
                        });
                    }
                }
            });
            
            // 노드 정의에는 들여쓰기 없이
            Object.values(groups).forEach(group => {
                mermaidString += `subgraph ${group.id} \n`;
                Object.values(group.classes).forEach(cls => {
                    mermaidString += `${cls.id}[-${cls.role}-<br/>${cls.id}]\n`;  // 들여쓰기 제거
                });
                mermaidString += `end\n`;
            });
            
            // 관계 정의에만 들여쓰기 유지
            relSet.forEach(rel => {
                mermaidString += `${rel}\n`;  // 이미 relSet에 들여쓰기가 포함되어 있음
            });

            this.mermaidDtos[key].mermaidString = mermaidString;
            this.mermaidDtos[key].renderKey++;
            
            return this.mermaidDtos[key].mermaidString;
        },

        getAggregateMermaidRenderKey(index, optionIndex) {
            const key = `${index}-${optionIndex}`;
            return this.mermaidDtos[key] ? this.mermaidDtos[key].renderKey : 0;
        },

        generateBPMN() {
            let analysisResult = this.getProcessAnalysisMessages[0].content.analysisResult;

            if (!analysisResult || !analysisResult.actors || !analysisResult.events) {
                this.bpmXml = null;
                return;
            }
            const { actors, events } = analysisResult;

            // 1. 이벤트를 레벨 순서대로 정렬
            const eventsByLevel = [...events].sort((a, b) => a.level - b.level);

            // 2. 각 액터별로 이벤트를 level 순서대로 정렬
            const actorEventMap = {};
            actors.forEach(actor => {
                actorEventMap[actor.name] = [];
            });
            eventsByLevel.forEach(ev => {
                if (actorEventMap[ev.actor]) {
                    actorEventMap[ev.actor].push(ev.name);
                }
            });

            // 3. Pool/Lane 정의 (flowNodeRef를 level 순서대로)
            let lanes = actors.map(actor => `
                <bpmn:lane id="Lane_${actor.lane}" name="${actor.name}">
                    ${actorEventMap[actor.name].map(ev => `<bpmn:flowNodeRef>${ev}</bpmn:flowNodeRef>`).join('\n')}
                </bpmn:lane>
            `).join('\n');

            // 4. 이벤트(Task/Start/End 등) 정의 (level 순서대로)
            let eventMap = {};
            let flowNodes = eventsByLevel.map(ev => {
                eventMap[ev.name] = ev;
                if (ev.level === 1) {
                    return `<bpmn:startEvent id="${ev.name}" name="${ev.displayName}" />`;
                } else if (!ev.nextEvents || ev.nextEvents.length === 0) {
                    return `<bpmn:endEvent id="${ev.name}" name="${ev.displayName}" />`;
                } else {
                    return `<bpmn:task id="${ev.name}" name="${ev.displayName}" />`;
                }
            }).join('\n');

            // 5. 시퀀스 플로우 정의
            let sequenceFlows = [];
            events.forEach(ev => {
                if (ev.nextEvents) {
                    ev.nextEvents.forEach(next => {
                        sequenceFlows.push(
                            `<bpmn:sequenceFlow id="Flow_${ev.name}_to_${next}" sourceRef="${ev.name}" targetRef="${next}" />`
                        );
                    });
                }
            });

            // 6. 시각적 요소(BPMN-DI) 생성
            // 각 lane(액터)별로 y축을 다르게, 각 이벤트는 level에 따라 x축을 다르게 배치
            const laneHeight = 160; // 더 크게!
            const nodeWidth = 80;
            const nodeHeight = 60;
            const xGap = 140;
            const yStart = 80;
            const xStart = 100;

            // 이벤트별 위치 계산
            const nodePositions = {};
            actors.forEach((actor, laneIdx) => {
                actorEventMap[actor.name].forEach(evName => {
                    const ev = events.find(e => e.name === evName);
                    if (!ev) return;
                    // x: level에 따라, y: lane에 따라
                    nodePositions[evName] = {
                        x: xStart + (ev.level - 1) * xGap,
                        y: yStart + laneIdx * laneHeight
                    };
                });
            });

            // Lane의 BPMNShape 생성 (선택)
            let bpmnLaneShapes = actors.map((actor, laneIdx) => {
                // lane의 높이는 해당 lane의 노드 개수에 따라 동적으로 조정할 수도 있음
                return `
                <bpmndi:BPMNShape id="Shape_Lane_${actor.lane}" bpmnElement="Lane_${actor.lane}">
                    <dc:Bounds x="0" y="${yStart + laneIdx * laneHeight - 20}" width="${xStart + xGap * 15}" height="${laneHeight}" />
                </bpmndi:BPMNShape>
                `;
            }).join('\n');

            // BPMNShape 생성
            let bpmnShapes = Object.entries(nodePositions).map(([evName, pos]) => {
                return `
                <bpmndi:BPMNShape id="Shape_${evName}" bpmnElement="${evName}">
                    <dc:Bounds x="${pos.x}" y="${pos.y}" width="${nodeWidth}" height="${nodeHeight}"/>
                </bpmndi:BPMNShape>
                `;
            }).join('\n');

            // BPMNEdge(시퀀스 플로우) 생성
            let bpmnEdges = sequenceFlows.map(flowXml => {
                const match = flowXml.match(/sourceRef="([^"]+)" targetRef="([^"]+)"/);
                if (!match) return '';
                const [, source, target] = match;
                const src = nodePositions[source];
                const tgt = nodePositions[target];
                if (!src || !tgt) return '';
                const waypoints = [
                    `<di:waypoint x="${src.x + nodeWidth}" y="${src.y + nodeHeight/2}"/>`,
                    `<di:waypoint x="${tgt.x}" y="${tgt.y + nodeHeight/2}"/>`
                ].join('\n');
                return `
                <bpmndi:BPMNEdge id="Edge_${source}_to_${target}" bpmnElement="Flow_${source}_to_${target}">
                    ${waypoints}
                </bpmndi:BPMNEdge>
                `;
            }).join('\n');

            // 7. 프로세스 조립
            this.bpmXml = `<?xml version="1.0" encoding="UTF-8"?>
        <bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                        xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"
                        xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
                        xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
                        xmlns:di="http://www.omg.org/spec/DD/20100524/DI"
                        id="Definitions_1"
                        targetNamespace="http://bpmn.io/schema/bpmn">
        <bpmn:process id="Process_1" isExecutable="false">
            <bpmn:laneSet>
            ${lanes}
            </bpmn:laneSet>
            ${flowNodes}
            ${sequenceFlows.join('\n')}
        </bpmn:process>
        <bpmndi:BPMNDiagram id="BPMNDiagram_1">
            <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
            ${bpmnLaneShapes}
            ${bpmnShapes}
            ${bpmnEdges}
            </bpmndi:BPMNPlane>
        </bpmndi:BPMNDiagram>
        </bpmn:definitions>
        `;
        }
    }
}
</script>

<style scoped>
/* 기본 레이아웃 */
.document-template {
    background: white;
    padding: 20px;
    margin: 0 auto;
    max-width: 210mm;
}

/* 표지 스타일 */
.cover {
    height: 297mm;
    padding: 60px 40px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    text-align: center;
}

.main-title {
    font-size: 36px;
    font-weight: bold;
    margin-top: 100px;
}

.subtitle {
    font-size: 24px;
    margin-top: 40px;
}

.logo-container {
    margin: auto;
}

.logo {
    width: 200px;
}

.footer {
    font-size: 14px;
    color: #666;
}

/* 목차 스타일 */
.table-of-contents {
    padding: 40px;
}

.toc-list {
    margin-top: 20px;
}

.toc-list li {
    margin: 10px 0;
}

.toc-list ul {
    margin-left: 20px;
    list-style-type: none;
}

/* 섹션 스타일 */
.section {
    margin-bottom: 70px;
    padding: 20px 0;
    position: relative;
}

.section-content {
    padding: 20px 0;
}

/* 제목 스타일 */
h2 {
    font-size: 28px;
    color: #333;
    margin-bottom: 30px;
    padding-bottom: 15px;
    position: relative;
    border-bottom: 3px solid #333;
}

h2:after {
    content: '';
    position: absolute;
    bottom: -3px;
    left: 0;
    width: 100px;
    height: 3px;
    background: #4CAF50;
}

h3 {
    font-size: 22px;
    color: #444;
    margin: 25px 0 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #ddd;
}

h4 {
    font-size: 18px;
    color: #555;
    margin: 20px 0 10px;
}

/* 액터 카드 스타일 */
.actor-section {
    margin: 20px 0;
}

.actor-item {
    margin-bottom: 1.5em;
    padding-bottom: 1em;
    border-bottom: 1px solid #eee;
}

.actor-item:last-child {
    border-bottom: none;
}

.actor-name {
    margin-bottom: 0.5em;
    font-size: 1.1em;
}

.actor-lane {
    color: #666;
    margin-left: 8px;
    font-size: 0.9em;
}

.actor-events {
    color: #333;
    line-height: 1.4;
}

.events-label {
    color: #666;
    margin-right: 8px;
}

.event-item:last-child {
    all: unset;
}

.story-content {
    width: 100%;
    white-space: pre-line;
}

.story-paragraph {
    margin-bottom: 1.5em;
    line-height: 1.5;
    font-size: 0.9em;
    text-align: justify;
    word-break: keep-all;
    overflow-wrap: break-word;
    display: block;
    width: 100%;
}

/* PDF 변환 관련 스타일 */
.pdf-content-item {
    margin-bottom: 20px;
    position: relative;
    padding: 20px;
    border: 1px solid #ccc;
    min-height: 297mm;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    background: white;
    transform: translateZ(0); /* 하드웨어 가속 활성화 */
    -webkit-font-smoothing: antialiased; /* 폰트 스무딩 */
}

/* 다이어그램 컨테이너 스타일 */
.mermaid-container, .bpmn-uengine-viewer {
    background: white;
    padding: 10px;
    border: 1px solid #eee;
    border-radius: 4px;
    margin: 10px 0;
    transform: translateZ(0);
}

/* 텍스트 컨텐츠 스타일 */
.story-content, .actor-section, .section-content {
    margin: 10px 0;
    transform: translateZ(0);
}

/* 테이블 스타일 */
.v-simple-table {
    margin: 10px 0;
    transform: translateZ(0);
}

/* 이미지 최적화 */
img {
    max-width: 100%;
    height: auto;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
}

/* 다이어그램 내부 요소 */
.mermaid-container svg,
.bpmn-uengine-viewer svg {
    max-width: 100%;
    height: auto;
    transform: translateZ(0);
}

/* 밸류 스트림 다이어그램 스타일 */
.value-stream-diagram {
    margin: 30px 0;
    height: 400px;
    border: 2px dashed #e0e0e0;
    border-radius: 8px;
    background: #fafafa;
}

.work-in-progress {
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
}

.wip-text {
    text-align: center;
    margin-top: 20px;
}

/* 바운디드 컨텍스트 추가 정보 */
.bounded-context-table, .relations-table {
    margin-top: 20px;
    border: 1px solid #e0e0e0;
}

.bounded-context-table th, .relations-table th {
    background-color: #f5f5f5;
    font-weight: bold;
    padding: 12px;
    text-align: left;
}

.bounded-context-table td, .relations-table td {
    padding: 12px;
    border-bottom: 1px solid #e0e0e0;
}

.requirement-row {
    background-color: #fafafa;
}

.requirements-container {
    padding: 8px 0;
}

.requirement-item {
    margin: 8px 0;
    display: flex;
}

.requirement-number {
    min-width: 24px;
    color: #666;
}

.requirement-text {
    flex: 1;
}

/* Aggregate Drafts */
.aggregate-page {
    min-height: 297mm;
    max-height: 297mm;
    overflow: hidden;
}

.aggregate-models {
    margin-top: 20px;
}

.aggregate-option {
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
}

.analysis-section {
    margin-top: 15px;
}

.pros-cons-table {
    margin-top: 10px;
    border: 1px solid #e0e0e0;
    width: 100%;
    font-size: 0.9em;
}

.pros-cons-table th {
    background-color: #f5f5f5;
    font-weight: bold;
    padding: 8px;
    text-align: left;
}

.pros-cons-table td {
    padding: 8px;
    border-bottom: 1px solid #e0e0e0;
}

.pros-cons-table td:first-child {
    background-color: #fafafa;
    width: 100px;
    font-weight: bold;
}

/* 설계 기준 스타일 */
.design-criteria {
    margin: 20px 0;
    padding: 15px;
    background-color: white;
    flex: 1;
}

.criteria-section {
    margin-bottom: 30px;
}

.criteria-section:last-child {
    margin-bottom: 0;
}

.section-title {
    color: #333;
    font-size: 18px;
    margin-bottom: 15px;
    padding-bottom: 5px;
    border-bottom: 1px solid #ddd;
}

.rules-table,
.entity-table,
.events-table,
.interface-table {
    width: 100%;
    margin-bottom: 15px;
}

.rules-table td,
.entity-table td,
.events-table td,
.interface-table td {
    padding: 8px;
    border-bottom: 1px solid #eee;
}

.entity-name,
.interface-name {
    font-size: 16px;
    margin: 10px 0;
    color: #333;
}

.story-section {
    margin-bottom: 15px;
}

.story-title {
    font-size: 16px;
    margin: 10px 0;
    color: #333;
}

.story-description {
    margin: 8px 0;
    line-height: 1.5;
}

.story-acceptance {
    margin-top: 10px;
}

.acceptance-criterion {
    margin: 5px 0;
    line-height: 1.4;
}

.criteria-explanation {
    margin-top: 15px;
    line-height: 1.5;
}

/* 이벤트스토밍 모델 스타일 */
.bounded-context-detail {
    margin-bottom: 40px;
    padding: 20px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
}

.component-section {
    margin-top: 20px;
}

.component-section h5 {
    font-size: 16px;
    color: #333;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #ddd;
}

.component-table {
    margin-bottom: 20px;
}

.component-table th {
    background-color: #f5f5f5;
    font-weight: bold;
    padding: 8px;
    text-align: left;
}

.component-table td {
    padding: 8px;
    border-bottom: 1px solid #eee;
}

/* 애그리게잇 상세 정보 스타일 */
.aggregate-detail {
    margin-bottom: 30px;
    padding: 20px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    background-color: #fafafa;
}

.entity-detail {
    margin: 15px 0;
    padding: 15px;
    border: 1px solid #eee;
    border-radius: 4px;
    background-color: white;
}

.entity-header {
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #ddd;
}

.entity-display-name {
    color: #666;
    margin-left: 8px;
    font-size: 0.9em;
}

.field-table, .enum-table {
    margin-top: 10px;
}

.field-table th, .enum-table th {
    background-color: #f5f5f5;
    font-weight: bold;
    padding: 8px;
    text-align: left;
}

.field-table td, .enum-table td {
    padding: 8px;
    border-bottom: 1px solid #eee;
}
</style>